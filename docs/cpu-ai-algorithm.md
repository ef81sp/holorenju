# CPU AIアルゴリズム

このドキュメントでは、CPU対戦機能で使用されるAIアルゴリズムの仕組みと調整方法について説明します。

## 概要

CPU AIは以下のアルゴリズムを組み合わせて実装されています:

- **Minimax探索**: 相手が最善手を打つと仮定し、最良の手を選択
- **Alpha-Beta剪定**: 不要な探索を省略して効率化
- **Iterative Deepening**: 時間制限内で段階的に深く探索
- **Transposition Table**: 同一局面の重複計算を回避
- **Move Ordering**: 候補手を優先度順にソートして剪定効率を向上

## 難易度調整パラメータ

難易度は `src/types/cpu.ts` の `DIFFICULTY_PARAMS` で定義されています。

| 難易度   | depth | timeLimit | randomFactor |
| -------- | ----- | --------- | ------------ |
| beginner | 2     | 1000ms    | 0.30 (30%)   |
| easy     | 3     | 2000ms    | 0.15 (15%)   |
| medium   | 4     | 3000ms    | 0.00 (0%)    |
| hard     | 5     | 5000ms    | 0.00 (0%)    |

### パラメータの意味

#### depth（探索深度）

何手先まで読むかを指定します。

- 値が大きいほど強くなるが、探索時間が指数関数的に増加
- Iterative Deepeningにより、時間制限内で到達可能な深度まで探索

#### timeLimit（時間制限）

1手あたりの最大思考時間（ミリ秒）です。

- 探索は時間制限の50%を超えた時点で次の深度への移行を中断
- 時間内に完了した最深の探索結果を使用

#### randomFactor（ランダム要素）

AIの着手にランダム性を加える確率です。

- `randomFactor > 0` の場合、その確率で上位N手（候補数の1/3程度）からランダム選択
- beginner/easyでは意図的に「最善手でない手」を打つことで弱く見せる
- medium/hardでは0（常に最善手を選択）

## 評価関数

評価関数は `src/logic/cpuAI/evaluation.ts` に実装されています。

### パターンスコア

石のパターンを検出し、スコアを付与します:

| パターン       | スコア  | 説明                     |
| -------------- | ------- | ------------------------ |
| FIVE           | 100,000 | 五連（勝利）             |
| OPEN_FOUR      | 10,000  | 活四（両端が開いた四連） |
| FOUR           | 1,000   | 止め四（片端のみ開）     |
| OPEN_THREE     | 1,000   | 活三（両端が開いた三連） |
| THREE          | 100     | 止め三（片端のみ開）     |
| OPEN_TWO       | 50      | 活二                     |
| TWO            | 10      | 止め二                   |
| CENTER_BONUS   | 5       | 中央寄りボーナス         |
| FORBIDDEN_TRAP | 100     | 禁じ手誘導ボーナス       |

### 評価の計算方法

1. **攻撃スコア**: 自分のパターンスコアの合計
2. **防御スコア**: 相手がその位置に置いた場合のスコア × 0.5（ブロック価値）
3. **中央ボーナス**: 天元(7,7)からの距離に基づくボーナス

```
総合スコア = 攻撃スコア + 防御スコア + 中央ボーナス
```

盤面全体の評価は:

```
盤面スコア = 自分のパターンスコア合計 - 相手のパターンスコア合計
```

## 探索の最適化

### Iterative Deepening（段階的深化）

`findBestMoveIterativeWithTT()` で実装。

1. 深さ1から探索を開始
2. 時間制限内で可能な限り深く探索
3. 各深度の結果を保存し、時間切れの場合は最後に完了した深度の結果を使用

**メリット**:

- 時間制限を守りながら最大限深く探索
- 浅い探索の結果を深い探索のMove Orderingに活用

### Move Ordering（候補手の優先順位）

`src/logic/cpuAI/moveGenerator.ts` の `sortMoves()` で実装。

優先度（高い順）:

1. **TT最善手** (+1,000,000): 置換表に記録された最善手
2. **Killer Moves** (+100,000〜90,000): 同じ深さで剪定を引き起こした手
3. **静的評価**: `evaluatePosition()` による攻撃・防御価値
4. **History Heuristic**: 過去に剪定を引き起こした手の統計

**Killer Moves**:

- 各深度で最大2つの手を記録
- Beta cutoffを引き起こした手は、同じ深度の他の局面でも有効な可能性が高い

**History Heuristic**:

- cutoffを引き起こした手の位置に `depth²` のスコアを加算
- 深い探索でのcutoffほど重要として扱う

### Transposition Table（置換表）

`src/logic/cpuAI/transpositionTable.ts` で実装。

同一局面の重複計算を回避するキャッシュ。異なる手順で同じ局面に到達した場合、以前の計算結果を再利用します。

**エントリの内容**:

- `hash`: 盤面のZobristハッシュ
- `score`: 評価スコア
- `depth`: 探索深度
- `type`: スコアタイプ（EXACT / LOWER_BOUND / UPPER_BOUND）
- `bestMove`: この局面での最善手
- `generation`: 世代番号（古いエントリ置換用）

**置換戦略**:

- 新しいエントリの深度が深い場合は置換
- 既存エントリが古い世代の場合は置換
- EXACT（正確な評価値）は優先的に保持

**サイズ管理**:

- 最大100万エントリ
- 上限超過時は古い世代のエントリを優先的に削除

### Zobrist Hashing

`src/logic/cpuAI/zobrist.ts` で実装。

盤面を高速にハッシュ化する手法。XOR演算により差分更新が可能で、石を置くたびに全盤面を再計算する必要がありません。

**仕組み**:

1. 各位置・各色に対してユニークな64ビット乱数を事前生成
2. 盤面ハッシュは、すべての石のZobrist値をXORした結果
3. 石を置く/取る操作は、該当位置のZobrist値とXORするだけ

```
新ハッシュ = 現在のハッシュ XOR Zobrist[row][col][color]
```

## 特殊処理

### 開局フェーズ（珠型パターン）

`src/logic/cpuAI/opening.ts` で実装。

連珠では最初の3手に定型パターン（珠型）があります:

1. **1手目（黒）**: 天元(7,7)に置く
2. **2手目（白）**: 天元の周囲8マスからランダムに選択
3. **3手目（黒）**: 白の位置に応じた珠型パターンからランダムに選択

**珠型パターン**:

- **直打ち（斜め）**: 寒星、花月、雨月、金星、松月、丘月、新月、瑞星、山月、遊星、彗星、残月、明星
- **間打ち（縦横）**: 瑞星、山月、溪月、寒星、水月、流星、雲月、浦月、峡月、岩月、銀月、名月、恒星

4手目以降は通常のMinimax探索に移行します。

### 禁手チェック

黒番では禁手（三三禁、四四禁、長連禁）をチェックし、禁手となる位置は候補手から除外します。ただし、五連が作れる場合は禁手でも候補に含めます（五連は禁手より優先）。

## 調整ガイドライン

### 難易度を変更する場合

| 変更内容                 | 効果                             |
| ------------------------ | -------------------------------- |
| depth を増やす           | より強く（ただし思考時間が増加） |
| timeLimit を増やす       | 深い探索が完了する確率が上がる   |
| randomFactor を増やす    | より弱く（意図的にミスを増やす） |
| randomFactor を 0 にする | 常に最善手を選択（安定した強さ） |

### 評価関数を調整する場合

| 変更内容                 | 効果                                 |
| ------------------------ | ------------------------------------ |
| OPEN_FOUR を高くする     | 活四をより重視（攻撃的になる）       |
| FOUR/THREE を高くする    | 止め四/三をより重視                  |
| 防御スコアの係数を上げる | 相手の攻撃をより警戒（守備的になる） |
| CENTER_BONUS を高くする  | より中央寄りに打つ傾向               |

## 実装予定

連珠の戦術・ルールに基づき、以下の機能を実装予定です。

### 優先度: 最高

#### 跳び三・跳び四の検出

現在は連続した石のみを検出しているが、1マス空いた形も同等の脅威を持つ。

| パターン | 形の例           | 提案スコア     |
| -------- | ---------------- | -------------- |
| 跳び四   | `○_○○○`, `○○_○○` | FOUR と同等    |
| 跳び三   | `○_○○`, `○○_○`   | THREE と同等   |
| 活跳び三 | `_○_○○_`         | OPEN_THREE同等 |

**実装方針**: `analyzeDirection()` を拡張し、1マス空きのパターンも検出

#### 四三同時作成ボーナス

四と三を同時に作る手は、黒の主な勝ちパターン。

```
現状: OPEN_FOUR(10000) + OPEN_THREE(1000) = 11000
提案: 四三同時ボーナス +5000 → 合計 16000
```

**実装方針**: `evaluatePosition()` で4方向のパターンを分析後、四と三が同時に存在する場合にボーナス加算

### 優先度: 高

#### 白の三三・四四を勝利扱い

白には禁手がないため、三三・四四は即勝利となる。

| パターン | 現状   | 提案        |
| -------- | ------ | ----------- |
| 白の三三 | 未対応 | FIVE と同等 |
| 白の四四 | 未対応 | FIVE と同等 |
| 白の長連 | 対応済 | FIVE と同等 |

**実装方針**: 白番の評価時に、活三が2つ以上または四が2つ以上あれば FIVE スコアを返す

#### 禁手追い込み（ハメ手）評価の強化

黒が禁手位置でしか防御できない状況は、白の勝利確定。

| 状況                       | 現状   | 提案スコア  |
| -------------------------- | ------ | ----------- |
| 黒の防御位置が禁手         | 100    | +5000~10000 |
| 禁手への誘導手（ネライ手） | 未対応 | +1000~2000  |

**実装方針**: 白番で四や活三を作る際、黒の止め位置が禁手かどうかをチェック

#### ミセ手・フクミ手の検出

| 用語     | 説明                      | 提案スコア |
| -------- | ------------------------- | ---------- |
| ミセ手   | 次に四三を作れる手        | +500~1000  |
| フクミ手 | 次にVCF（四追い勝ち）の手 | +800~1500  |

**ミセ手の判定アルゴリズム**:

```
1. 仮に石を置く
2. その位置から4方向をスキャン
3. 活三パターンの数と、二連以上のパターンの数をカウント
4. 以下のいずれかを満たせばミセ手:
   - 活三 >= 1 かつ 別方向に二連以上 >= 1
   - 次の手で活三を2方向に作れる位置がある
```

**フクミ手の判定アルゴリズム（軽量版VCF探索）**:

```
VCF探索（深さ制限8手）:
1. 現在の局面で四が作れる位置を列挙
2. 各位置について:
   a. 四を作る
   b. 相手は必ずその四を止める（止め方は1通り）
   c. 止めた後の局面で再帰的にVCF探索
3. 五連に到達できればVCF成立
4. 深さ制限で打ち切り
```

四の分岐のみを追うため、通常のMinimax探索より大幅に軽量。

### 優先度: 中

#### 複数方向脅威ボーナス

次に2通り以上の勝ち方がある状態を作る手は高評価。

**実装方針**: 4方向のパターン評価後、高スコア（OPEN_THREE以上）のパターンが2つ以上あればボーナス +500

#### カウンターフォー（防御兼攻撃）

単に相手の脅威を止めるだけでなく、自分も四を作りながら止める手。

**実装方針**: 防御スコアの計算時、自分の攻撃スコアも高い場合に係数1.5倍

#### VCT探索（三も含む脅威連続）

VCFより広い概念で、三・四を連続して打つことで勝利する手順。
計算コストが高いため、終盤限定または深さ制限を厳しくする。

### 優先度: 低

#### 斜め方向ボーナス

斜め連は隣接点が多く、石の効率が高い（斜め二連: 12点、縦横二連: 10点）。

**実装方針**: 斜め方向のパターンに +5% のボーナス

#### 開局パターン評価

珠型ごとの有利不利を評価。

| 珠型       | 評価       |
| ---------- | ---------- |
| 花月、浦月 | 黒必勝     |
| 疎星、流星 | 黒有利     |
| 渓月、峡月 | 黒やや有利 |

**実装方針**: 開局データベースとの照合、または開局パターンに基づく初期評価ボーナス

### 探索アルゴリズムの改善（将来）

1. **Null Move Pruning**: 自分がパスしても有利なら枝刈り
2. **Late Move Reduction（LMR）**: 後半の候補手は浅く探索
3. **Aspiration Window**: 前回の評価値付近のみを探索
4. **Opening Book**: 定石データベースの導入

## ファイル構成

| ファイル                      | 役割                             |
| ----------------------------- | -------------------------------- |
| `types/cpu.ts`                | 難易度パラメータ、型定義         |
| `cpuAI/minimax.ts`            | Minimax探索、Iterative Deepening |
| `cpuAI/evaluation.ts`         | 評価関数、パターンスコア         |
| `cpuAI/moveGenerator.ts`      | 候補手生成、Move Ordering        |
| `cpuAI/transpositionTable.ts` | 置換表                           |
| `cpuAI/zobrist.ts`            | Zobristハッシュ                  |
| `cpuAI/opening.ts`            | 開局処理（珠型パターン）         |
