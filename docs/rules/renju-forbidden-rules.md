# 連珠 禁手判定ルール

## 概要

連珠（競技五目並べ）では、黒石のみに「禁手」と呼ばれる着手制限がある。
本ドキュメントでは、禁手判定の詳細ルールを解説する。

## 基本の禁手

### 1. 長連禁（ちょうれんきん）

6個以上の石が連続する形。黒は禁手。

```
●●●●●● → 6連以上は禁手
```

### 2. 四四禁（しし きん）

同時に2つ以上の「四」を作る手。黒は禁手。

```
    ●
    ●
●●●*●  → *に置くと横と縦に四ができる = 四四禁
    ●
```

### 3. 三三禁（さんさん きん）

同時に2つ以上の「活三」を作る手。黒は禁手。

```
  ●
  ●
・●*●・  → *に置くと横と縦に活三ができる = 三三禁
```

## 重要な例外: 五連優先

**五連ができる手は、どんな形でも禁手にならない。**

```
●●●●*  → *に置くと五連 = 禁手ではない（たとえ三三や四四の形でも）
```

## 四と三の定義

### 四（し）

1個加えると五連になる形。以下の種類がある：

| 名称     | 形            | 説明               |
| -------- | ------------- | ------------------ |
| **達四** | `・●●●●・`    | 両端開き。最強の四 |
| **跳四** | `●●●・●` など | 飛び四             |
| **止四** | `白●●●●・`    | 片端塞がり         |

### 三（さん）

1個加えると**達四**になる形。単なる四ではなく、達四になることが条件。

| 名称       | 形          | 説明                          |
| ---------- | ----------- | ----------------------------- |
| **活三**   | `・●●●・`   | 両端開きの連続三              |
| **飛び三** | `・●●・●・` | 1マス空きの三（飛びが達四点） |

## 飛び型パターン

### 飛び三

1つの空きを含む3石のパターンで、空きを埋めると達四になる。

```
・●●・●・  → ●●・● 型（達四点は3番目の空き）
・●・●●・  → ●・●● 型（達四点は2番目の空き）
```

### 飛び四

1つの空きを含む4石のパターンで、空きを埋めると五連になる。

```
●●●・●  → 3連 + 空き + 1石
●●・●●  → 2連 + 空き + 2連
●・●●●  → 1石 + 空き + 3連
```

## ウソの三

### 定義

**見かけ上は活三だが、達四点がすべて禁点のため、実際には三として認められない形。**

### 例

```
盤面: row=7
cols: 1  2  3  4  5  6  7  8  9 10 11 12
      ● ● ● ●  ・ ●  *  ・ ● ●  ●  ●

*に置くと、cols 5,6,7 が三のように見える。
しかし：
- 達四点 col=5 に置くと 6連（長連禁）
- 達四点 col=8 に置くと 6連（長連禁）

すべての達四点が禁点 → ウソの三 → 三としてカウントしない
```

### 判定ロジック

```
isValidThree(三の達四点リスト):
  for each 達四点:
    if 達四点が禁点ではない:
      return true  // 有効な三
  return false  // ウソの三
```

## 否三々（ひさんさん）

### 定義

**見かけ上は三三禁だが、相互参照により禁手が成立しないケース。**

### メカニズム

```
点Aの禁手判定:
  └─ 三Xの達四点Bを検証
      └─ 点Bの禁手判定
          └─ 三Yの達四点Aを検証
              └─ 点Aは判定中... → 循環参照！
```

循環参照が発生した場合、「禁点ではない」として扱う。
これにより、AもBも実際には禁点にならない。

### 判定ロジック

```typescript
interface ForbiddenCheckContext {
  inProgress: Set<string>;  // 現在判定中の点
  cache: Map<string, Result>;
}

checkForbiddenMoveRecursive(board, row, col, context):
  key = `${row},${col}`

  // 循環参照検出
  if key in context.inProgress:
    return { isForbidden: false }  // 否三々

  // 判定中としてマーク
  context.inProgress.add(key)

  // 通常の禁手判定を実行
  result = checkForbiddenMoveInternal(board, row, col, context)

  // 判定完了
  context.inProgress.delete(key)

  return result
```

## 判定フローチャート

```
checkForbiddenMove(board, row, col)
│
├─ 空きマス？ ─No─→ 禁手ではない
│
├─ 五連になる？ ─Yes─→ 禁手ではない（五連優先）
│
├─ 長連になる？ ─Yes─→ 長連禁
│
├─ 四四になる？
│   └─ 連続四 + 飛び四をカウント
│   └─ 2つ以上 ─Yes─→ 四四禁
│
└─ 三三になる？
    └─ 連続三 + 飛び三を列挙
    └─ 各三について isValidThree() で検証
        └─ 達四点が禁点か再帰チェック（循環参照検出付き）
    └─ 有効な三が2つ以上 ─Yes─→ 三三禁
    │
    └─ 禁手ではない
```

## 実装ファイル

- `src/logic/renjuRules.ts` - 禁手判定ロジック
- `src/logic/renjuRules.test.ts` - テストケース

## 参考資料

- [連珠(五目並べ)入門 for プログラマ - Qiita](https://qiita.com/YSRKEN/items/81f97660be023add2265)
- [RIF Rules - RenjuNet](https://www.renju.net/rifrules/)
